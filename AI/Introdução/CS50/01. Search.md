# Lecture 1 - Search

## Terminologia (intro)
- **Agent**
	- Entidade que percebe e interage com o ambiente.
- **State**
	- Configuração em um determinado instante.
- **Actions**
	- Escolhas que podem ser realizadas em qualquer estado.
	- `action(s)`
	- Recebe um input s (onde s é algum estado existente no ambiente)
	- Retorna como saída o conjunto de todas as ações que podem ser executadas nesse estado.
- **Modelo de transição**
	- Descrição do estado que obtemos depois de executarmos uma ação em outro estado de origem.
	- `result(s, a)`
	- Retorna o estado resultante de uma ação `a` no estado `s`
- **State Space**
	- O ocnjunto de todos os estados alcançáveis a partir de um estado inicial, a partir de uma sequência de ações.
	- Representação por [[2. Grafos em C|grafos]]
- **Goal Test**
	- Forma de determinar se um estado é um estado de meta (objetivo alcançado).
		- Exemplo: destino em um GPS; Peças de um quebra cabeça posicionadas em ordem.
- **Path cost**
	- Custo numérico associado a percorrer um certo caminho.
		- "Inicial state ao goal state pelo melhor path cost."
		- Grafos ponderados - vértices com valores;
		- Número de etapas.

---
## Search Problem
- initial state
- actions
- transition model
- goal test
- path cost function

- **optimal solution**
	- sequência de *ações* que nos levará do *estado inicial* ao *estado objetivo*, com o **melhor(menor)** *custo* de caminho.

- **node**
	- estrutura de dados que contém
		- estado
		- parent (node que gerou esse node - pai)
		- action (ações aplicada ao nó parent para chegar ao node atual)
		- path cost (do estado inicial ao node atual)
- **fronteira**
	- todas as opções disponíveis armazenadas em uma única estrutura de dados.
	- limite que separa os estados/node já explorados que ainda precisam ser explorados durante a busca.
	- a fronteira é dinâmica e muda à medida que a busca avança.
	- o objetivo é ajudar a guiar a busca para alcançar o objetivo de forma eficiente, evitando estados reduntantes e explorando novas possibildiades de maneira sistemática.
	- conforme estados são explorados, a fronteira se **contrai**;
	- conforme novos estados são adicionados, a fronteira se **expande**.

### Depth-First and Breadth-First 
**Abordagem Pseudo código:**

- Se uma fronteira ficar **vazia** significa que o problema *não tem solução*.
- Se já *exploramos* um nó, não há necessidade de voltar a ele.
	- Evita que o algortimo fique preso em um loop infinito.
- Se o nó atual for um nó que atenda o Goal Teste, ele é a *solução*.

- *Start* with a ==frontier== (**Stack**) tha contains the *initial state*
- *Start* with an empty ==explored set== (**Stack** - conjunto de nós explorados)
- Repeat: 
	- *If* the frontier is empty, *then* no solution.
	- *Remove* a node from the frontier;
	- *If* the node contains *goal* state, *return* the solution;
	- *Add* the node to the **explored set**;
	- *Else*, **expand** node, *add* **resulting nodes** to the *frontier* ==**somente se** eles não estejam na fronteira ou no explore set==.

> Em AI, usamos o termo **expandir o nó** para dizquer que iremos observar todos os vizinhos desse nó - ou seja, considerar todas as ações possíveis que poderíamos realizar do nó atual, e quais nós poderíamos alcançar.

- ==***Depth-First Search (DFS)***==
	- Usamos o conceito do pseudocódigo acima, para pesquisar em uma árvore, de forma que exploramos sempre o *nó mais profundo* da *fronteira*.
	  
![[depth-first search|100%]]

- ==***Breadth-First Search (BFS)***==
	- Pesquisa em largura: sempre explorará o **nó mais raso** da fronteira.
	- Em vez de usar uma *stack* (last-in first-out data type) com profundidade de primeira pesquisa ou DFS - onde o item mais recente adicionado à fronteira é o que exploramos a seguir -, na BFS usaremos uma **queue** (**first-in first-out data type**).
	- Quanto mais cedo um nó chegar a fronteira, mais cedo ele será explorado.
	
![[breadth-first search|100%]]

- Podemos concluir que em caso de buscas e rotas teremos duas diferenças
	- Breadth-first, conseguirá analisar caminhos/escolhas diferentes simultâneamente. Supondo que cada nó seja um caminho, podemos notar que C e D é verificado ao mesmo tempo. Isso significa que ele encontrará o caminho mais curto primeiro (apesar de ter levados menos iterações, em grafos mais densos, veremos que o BFS terá comportamente mais demorado);
	- Por outro lado, deep-first escolherá um caminho (aleatório), e então vai até o seu final, o que pode não retornar necessariamente o caminho mais curto, mas resolverá de forma mais rápida em problemas que tiverem muitas opções (pois o breatdh-first terá de analisar cada uma dessas várias análises).

<img src="https://lh3.googleusercontent.com/proxy/q59pA9oNEky3Zw5iyIZ4dg9bTLA0Ef56oxEe4C-HrgRmACmPEfvN2mACQOTGEims9usVIcZHQVwYVqmxb9ietZtsZjqPHV50v4Se3XU3NhU4vONPYkmWRQ">
- Na imagem (**grafo não ponderado**) podemos notar esse comportamento em múltiplos caminhos:
	- enquanto na breadth first, é analisado de forma simultânea: 1,4 e 6.
	- na deep-first analisamos de 1 -> 2 -> 4 -> 5 -> -> 6;
	- supondo que o destino fosse em 4, então podemos concluir que a pesquisa em breadth first encontraria o resultado em uma iteração. 
	- já a deep-first levaria 3 iterações.

- *Visulização gráfica Breadth-First Search (BFS)*
	- ![](https://www.youtube.com/watch?v=x-VTfcmrLEQ)
- *Visualização gráfica Deep-first Search (DFS)*
	- ![](https://www.youtube.com/watch?v=NUgMa5coCoE)
#### Breadth-First (BFS)
##### Prós
1. **Encontra o caminho mais curto em grafos não ponderados**: Como a BFS explora todos os vértices a partir do ponto de partida antes de se mover para os vértices vizinhos, ela sempre encontra o caminho mais curto entre dois vértices em um grafo não ponderado.
2. **Completeness**: BFS sempre encontra uma solução se houver uma. Se houver um caminho para o nó objetivo, a BFS encontrará esse caminho.
3. **Encontra todos os vértices acessíveis do vértice inicial em ordem crescente de distância**: A BFS visita todos os vértices de um grafo em uma ordem de "amplitude", ou seja, começa visitando todos os vizinhos diretos do vértice inicial, depois os vizinhos dos vizinhos e assim por diante. Isso pode ser útil para certos tipos de análises em grafos.

##### Contras
1. **Requer mais memória**: A BFS mantém uma fila para armazenar os nós a serem visitados. Em grafos grandes, isso pode resultar em um alto consumo de memória.
2. **Desempenho pior em grafos densos**: Em grafos densos, onde o número de arestas é grande, a BFS pode ter um desempenho pior em comparação com a DFS, devido à grande quantidade de memória necessária para manter a fila de vértices.

#### Depth-First (DFS):

##### Prós
1. **Menor uso de memória**: Ao contrário da BFS, a DFS não precisa armazenar todos os vértices visitados em uma fila, o que resulta em um menor consumo de memória. Ela utiliza a pilha de execução para manter o rastreamento de vértices a serem visitados.
2. **Melhor desempenho em grafos densos**: Em grafos densos, a DFS geralmente tem um desempenho melhor em comparação com a BFS devido ao menor uso de memória.
3. **Potencial para soluções mais rápidas**: Em alguns casos, a DFS pode encontrar uma solução mais rapidamente do que a BFS, especialmente quando o caminho mais curto não é uma prioridade.

##### Contras
1. **Não garante a solução mais curta em grafos não ponderados**: A DFS não é adequada para encontrar o caminho mais curto em grafos não ponderados, pois pode encontrar um caminho mais longo antes de encontrar o mais curto.
2. **Pode ficar presa em ciclos em grafos direcionados**: Se o grafo contiver ciclos, a DFS pode ficar presa em um ciclo infinito, a menos que seja modificada para evitar ciclos.

---
